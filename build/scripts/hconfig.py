#!/usr/bin/env python3
# coding=utf-8
# Copyright (c) CompanyNameMagicTag 2024-2024. All rights reserved.
"""
将sdk中的.config配置文件转换为.h文件
使配置项按#define Key Value 方式定义保存在.h文件中
"""

import os
import shutil
import argparse


def refresh_h_config(config_path, config_h_path, mode="replace"):
    """
    根据.config文件中的配置项，更新autoconfig.h文件
    update模式使用config配置更新现有.h
    replace模式使用config配置生成.h文件
    """
    conf_dict = read_config_file(config_path)
    if mode == "update":
        hconf_dict = read_config_h(config_h_path)
        for k, v in hconf_dict.items():
            if k in conf_dict:
                conf_dict[k] = hconf_dict[k]
        write_config_h(conf_dict, config_h_path)
    else:
        write_config_h(conf_dict, config_h_path)


def read_config_h(config_h_path):
    """
    读取autoconfig.h中的各项值
    """
    hconf_dict = {}
    # config_h_path：  os.path.join(sdk_dir, "build", "config", "autoconfig.h")
    if not os.path.isfile(config_h_path):
        return hconf_dict
    try:
        with open(config_h_path, encoding="utf-8", mode="r") as con_f:
            conf_lines = con_f.readlines()
    except UnicodeEncodeError:
        raise Exception("ini file has encoding error, check it.")
    except Exception:
        raise Exception("ini file has error, check it.")

    for line in conf_lines:
        line_sp = line.strip()
        if not line_sp:
            continue
        if line_sp.count(" ") < 2 or not line_sp.startswith("#define"):
            print("the item `%s` in autoconfig.h is not valid." % line_sp)
            continue
        elif not line_sp.startswith("#define"):
            print("the item `%s` in autoconfig.h is not startswith #define." % line_sp)
            continue
        else:
            pass
        sp_index = line_sp[8:].index(" ")
        k, v = line_sp[8: sp_index + 8].strip(), line_sp[sp_index + 8:].strip()
        if not k or not v:
            print("the item `%s` in autoconfig.h is not valid. no key or no value." % line_sp)
            continue
        if v.startswith("0x") or v.startswith("0X"):
            hconf_dict[k] = v
            continue
        v_int = v
        try:
            v_int = int(v)
        except (TypeError, ValueError):
            pass
        hconf_dict[k] = v_int
    return hconf_dict


def read_config_file(config_path):
    """
    读取ws73_default.config中的各项值
    """
    conf_dict = {}
    if not os.path.isfile(config_path):
        return conf_dict
    try:
        with open(config_path, encoding="utf-8", mode="r") as con_f:
            conf_lines = con_f.readlines()
    except UnicodeEncodeError:
        raise Exception("config file has encoding error, check it.")
    except Exception:
        raise Exception("config file has error, check it.")

    for line in conf_lines:
        line_sp = line.strip()
        if not line_sp:
            continue
        if "=" not in line_sp or line_sp.startswith("#"):
            continue
        sp_index = line_sp.index("=")
        k, v = line_sp[: sp_index].strip(), line_sp[sp_index + 1:].strip()

        # 获取的等式两边，任意一边为空
        if not k or not v:
            continue
        # 判读等式右边
        if v.startswith("0x") or v.startswith("0X"):
            conf_dict[k] = v
        elif v == "y":
            conf_dict[k] = 1
        elif v == "n":
            conf_dict[k] = 0
        else:
            v_int = v
            try:
                v_int = int(v)
            except (TypeError, ValueError):
                pass
            conf_dict[k] = v_int
    return conf_dict


def write_config_h(conf_dict, config_h_path):
    """
    写入.h文件
    """
    if not os.path.isfile(config_h_path):
        os.makedirs(os.path.dirname(config_h_path), exist_ok=True)
    content_str = []
    for k, v in conf_dict.items():
        item_str = "#define " + str(k) + " " + str(v)
        content_str.append(item_str)
    with open(config_h_path, encoding="utf-8", mode='w') as h_w:
        h_w.write("\n".join(content_str))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate config")
    parser.add_argument('kconfig_path', help="A Kconfig path")
    parser.add_argument('defconfig_path', help="The defconfig configuration path generated by menuconfig.")
    parser.add_argument('-a', '--autoheader',
                        help="Specify and generate the header file corresponding to the configuration.")
    parser.add_argument('-s', '--sync',
                        help="Synchronize kconfig configuration.", action='store_true')
    parser.add_argument('-u', '--update-options',
                        help="Update menuconfig configuration options like WSCFG_XXX=y", nargs='+')
    parser.add_argument('-t', '--title',
                        help="Specifies the menu header display.", default="WS73 configuration")
    parser.add_argument('-o', '--output-file',
                        help="Specify the saved file path.")

    args = parser.parse_args()
    CONFIG_PATH = args.defconfig_path
    OUTPUT_FILE = args.autoheader
    refresh_h_config(CONFIG_PATH, OUTPUT_FILE)

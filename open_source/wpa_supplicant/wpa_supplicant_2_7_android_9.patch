diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/Android.mk wpa_supplicant_8/Android.mk
--- origin_wpa/Android.mk	2023-05-22 11:07:36.999008779 +0800
+++ wpa_supplicant_8/Android.mk	2023-08-08 18:28:49.277642147 +0800
@@ -1,6 +1,6 @@
 LOCAL_PATH:= $(call my-dir)
 
-ifneq ($(filter VER_0_8_X VER_2_1_DEVEL,$(WPA_SUPPLICANT_VERSION)),)
+ifneq ($(filter VER_0_8_X_WS73 VER_2_1_DEVEL,$(WPA_SUPPLICANT_VERSION)),)
 # The order of the 2 Android.mks does matter!
 # TODO: Clean up the Android.mks, reset all the temporary variables at the
 # end of each Android.mk, so that one Android.mk doesn't depend on variables
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/hostapd/hidl/1.0/hostapd.cpp wpa_supplicant_8/hostapd/hidl/1.0/hostapd.cpp
--- origin_wpa/hostapd/hidl/1.0/hostapd.cpp	2023-05-22 11:07:36.999008779 +0800
+++ wpa_supplicant_8/hostapd/hidl/1.0/hostapd.cpp	2023-08-08 18:41:30.985636528 +0800
@@ -167,7 +167,8 @@
 	return StringPrintf(
 	    "interface=%s\n"
 	    "driver=nl80211\n"
-	    "ctrl_interface=/data/vendor/wifi/hostapd/ctrl\n"
+	    "ctrl_interface=/data/vendor/wifi/hostapd/sockets\n"
+		// "ctrl_interface=/data/vendor/wifi/hostapd/ctrl\n"
 	    // ssid2 signals to hostapd that the value is not a literal value
 	    // for use as a SSID.  In this case, we're giving it a hex
 	    // std::string and hostapd needs to expect that.
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/hostapd/src/drivers/driver_nl80211.c wpa_supplicant_8/hostapd/src/drivers/driver_nl80211.c
--- origin_wpa/hostapd/src/drivers/driver_nl80211.c	2023-05-22 11:07:37.031008779 +0800
+++ wpa_supplicant_8/hostapd/src/drivers/driver_nl80211.c	2023-08-01 17:22:22.060910125 +0800
@@ -10425,8 +10425,10 @@
 #ifdef ANDROID_P2P
 	.set_noa = wpa_driver_set_p2p_noa,
 	.get_noa = wpa_driver_get_p2p_noa,
-	.set_ap_wps_ie = wpa_driver_set_ap_wps_p2p_ie,
 #endif /* ANDROID_P2P */
+#if defined CONNECTIVITY_SET_P2P_IE_PATCH || defined ANDROID_P2P
+	.set_ap_wps_ie = wpa_driver_set_ap_wps_p2p_ie,
+#endif
 #ifdef ANDROID
 #ifndef ANDROID_LIB_STUB
 	.driver_cmd = wpa_driver_nl80211_driver_cmd,
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/hostapd/src/drivers/driver_nl80211.h wpa_supplicant_8/hostapd/src/drivers/driver_nl80211.h
--- origin_wpa/hostapd/src/drivers/driver_nl80211.h	2023-05-22 11:07:37.031008779 +0800
+++ wpa_supplicant_8/hostapd/src/drivers/driver_nl80211.h	2023-08-01 17:23:20.252073903 +0800
@@ -281,11 +281,13 @@
 int wpa_driver_set_p2p_noa(void *priv, u8 count, int start, int duration);
 int wpa_driver_get_p2p_noa(void *priv, u8 *buf, size_t len);
 int wpa_driver_set_p2p_ps(void *priv, int legacy_ps, int opp_ps, int ctwindow);
+#endif /* ANDROID_P2P */
+#endif /* ANDROID */
+#if defined CONNECTIVITY_SET_P2P_IE_PATCH || defined ANDROID || defined ANDROID_P2P
 int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
 				 const struct wpabuf *proberesp,
 				 const struct wpabuf *assocresp);
-#endif /* ANDROID_P2P */
-#endif /* ANDROID */
+#endif
 
 
 /* driver_nl80211_scan.c */
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/hostapd/src/drivers/driver_nl80211_android.c wpa_supplicant_8/hostapd/src/drivers/driver_nl80211_android.c
--- origin_wpa/hostapd/src/drivers/driver_nl80211_android.c	2023-05-22 11:07:37.031008779 +0800
+++ wpa_supplicant_8/hostapd/src/drivers/driver_nl80211_android.c	2023-08-01 17:24:52.981376217 +0800
@@ -19,7 +19,9 @@
 #include "utils/common.h"
 #include "driver_nl80211.h"
 #include "android_drv.h"
-
+#ifdef CONNECTIVITY_SET_P2P_IE_PATCH
+#include "wpa_supplicant_i.h"
+#endif
 
 typedef struct android_wifi_priv_cmd {
 	char *buf;
@@ -170,17 +172,117 @@
 	return -1;
 }
 
+#endif /* ANDROID_LIB_STUB */
+#endif /* ANDROID_P2P */
+
+#ifdef CONNECTIVITY_SET_P2P_IE_PATCH
+int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
+				  size_t buf_len)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct ifreq ifr;
+	android_wifi_priv_cmd priv_cmd;
+	int ret = 0;
+
+	if (bss->ifindex <= 0 && bss->wdev_id > 0) {
+		/* DRIVER CMD received on the DEDICATED P2P Interface which doesn't
+		 * have an NETDEVICE associated with it. So we have to re-route the
+		 * command to the parent NETDEVICE
+		 */
+		struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
+
+		wpa_printf(MSG_DEBUG, "Re-routing DRIVER cmd to parent iface");
+		if (wpa_s && wpa_s->parent) {
+			/* Update the nl80211 pointers corresponding to parent iface */
+			bss = wpa_s->parent->drv_priv;
+			drv = bss->drv;
+			wpa_printf(MSG_DEBUG, "Re-routing command to iface: %s"
+					      " cmd (%s)", bss->ifname, cmd);
+		}
+	}
+	os_memcpy(buf, cmd, strlen(cmd) + 1);
+	memset(&ifr, 0, sizeof(ifr));
+	memset(&priv_cmd, 0, sizeof(priv_cmd));
+	os_strlcpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
+	priv_cmd.buf = buf;
+	priv_cmd.used_len = buf_len;
+	priv_cmd.total_len = buf_len;
+	ifr.ifr_data = (void *)&priv_cmd;
+
+	if ((ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 1, &ifr)) < 0) {
+		wpa_printf(MSG_ERROR, "%s: failed to issue private command: %s", __func__, cmd);
+		wpa_driver_send_hang_msg(drv);
+	} else {
+		drv_errors = 0;
+		ret = 0;
+		if ((os_strcasecmp(cmd, "LINKSPEED") == 0) ||
+			(os_strcasecmp(cmd, "RSSI") == 0) ||
+			(os_strcasecmp(cmd, "GETBAND") == 0) ||
+			(os_strncasecmp(cmd, "WLS_BATCHING", 12) == 0))
+			ret = strlen(buf);
+		wpa_printf(MSG_DEBUG, "%s %s len = %d, %zu", __func__, buf, ret, strlen(buf));
+	}
+	return ret;
+}
 
 int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
 				 const struct wpabuf *proberesp,
 				 const struct wpabuf *assocresp)
 {
-	return 0;
-}
+	char *buf;
+	const struct wpabuf *ap_wps_p2p_ie = NULL;
+	char *_cmd = "SET_AP_WPS_P2P_IE";
+	char *pbuf;
+	int ret = 0;
+	int i, buf_len;
+	struct cmd_desc {
+		int cmd;
+		const struct wpabuf *src;
+	} cmd_arr[] = {
+		{0x1, beacon},
+		{0x2, proberesp},
+		{0x4, assocresp},
+		{-1, NULL}
+	};
+
+	wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
+	for (i = 0; cmd_arr[i].cmd != -1; i++) {
+		ap_wps_p2p_ie = cmd_arr[i].src;
+		if (ap_wps_p2p_ie) {
+			buf_len = strlen(_cmd) + 3 + wpabuf_len(ap_wps_p2p_ie);
+			buf = os_zalloc(buf_len);
+			if (NULL == buf) {
+				wpa_printf(MSG_ERROR, "%s: Out of memory",
+				__func__);
+				ret = -1;
+				break;
+			}
+		} else {
+		continue;
+		}
+		pbuf = buf;
+		pbuf += snprintf(pbuf, buf_len - wpabuf_len(ap_wps_p2p_ie),
+				"%s %d",_cmd, cmd_arr[i].cmd);
+		*pbuf++ = '\0';
+		os_memcpy(pbuf, wpabuf_head(ap_wps_p2p_ie), wpabuf_len(ap_wps_p2p_ie));
+		ret = wpa_driver_nl80211_driver_cmd(priv, buf, buf, buf_len);
+		os_free(buf);
+		if (ret < 0)
+			break;
+	}
 
-#endif /* ANDROID_LIB_STUB */
-#endif /* ANDROID_P2P */
+	return ret;
+}
 
+#elif defined(ANDROID_P2P) && defined(ANDROID_LIB_STUB)
+int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
+				 const struct wpabuf *proberesp,
+				 const struct wpabuf *assocresp)
+{
+	return 0;
+}
+#endif
 
 int android_nl_socket_set_nonblocking(struct nl_handle *handle)
 {
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/hostapd/src/drivers/drivers.mak wpa_supplicant_8/hostapd/src/drivers/drivers.mak
--- origin_wpa/hostapd/src/drivers/drivers.mak	2023-05-22 11:07:37.035008779 +0800
+++ wpa_supplicant_8/hostapd/src/drivers/drivers.mak	2023-08-01 17:26:04.936331828 +0800
@@ -37,6 +37,10 @@
 
 ifdef CONFIG_DRIVER_NL80211
 DRV_CFLAGS += -DCONFIG_DRIVER_NL80211
+ifdef CONNECTIVITY_SET_P2P_IE_PATCH
+DRV_CFLAGS += -I$(abspath ../wpa_supplicant/)
+DRV_OBJS += ../src/drivers/driver_nl80211_android.o
+endif
 DRV_OBJS += ../src/drivers/driver_nl80211.o
 DRV_OBJS += ../src/drivers/driver_nl80211_capa.o
 DRV_OBJS += ../src/drivers/driver_nl80211_event.o
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/hostapd/src/p2p/p2p.c wpa_supplicant_8/hostapd/src/p2p/p2p.c
--- origin_wpa/hostapd/src/p2p/p2p.c	2023-05-22 11:07:37.051008779 +0800
+++ wpa_supplicant_8/hostapd/src/p2p/p2p.c	2023-08-02 17:16:37.385498636 +0800
@@ -249,6 +249,21 @@
 	p2p->cfg->go_neg_completed(p2p->cfg->cb_ctx, &res);
 }
 
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+static int p2p_get_group_flag(struct p2p_data *p2p)
+{
+	size_t i;
+	struct p2p_group *group;
+
+	for (i = 0; i < p2p->num_groups; i++) {
+		group = p2p->groups[i];
+		if (os_memcmp(p2p_group_get_interface_addr(group),
+			p2p->cfg->dev_addr, ETH_ALEN) == 0)
+			return 1;
+	}
+	return 0;
+}
+#endif
 
 static void p2p_listen_in_find(struct p2p_data *p2p, int dev_disc)
 {
@@ -287,7 +302,14 @@
 		p2p_set_timeout(p2p, 0, 0);
 		return;
 	}
-
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	/* If the functions as the GO, no listening is required.*/
+	if (p2p_get_group_flag(p2p) == 1) {
+		p2p_dbg(p2p, "p2p_listen_in_find go no response");
+		p2p_set_timeout(p2p, 0, 0);
+		return;
+	}
+#endif
 	ies = p2p_build_probe_resp_ies(p2p, NULL, 0);
 	if (ies == NULL)
 		return;
@@ -337,6 +359,14 @@
 		return 0;
 	}
 
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	/* If the functions as the GO, no listening is required.*/
+	if (p2p_get_group_flag(p2p) == 1) {
+		p2p_dbg(p2p, "p2p_listen go no response");
+		p2p_set_state(p2p, P2P_LISTEN_ONLY);
+		return 0;
+	}
+#endif
 	ies = p2p_build_probe_resp_ies(p2p, NULL, 0);
 	if (ies == NULL)
 		return -1;
@@ -2242,8 +2272,19 @@
 
 	/* P2P IE */
 	len = p2p_buf_add_ie_hdr(buf);
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	u8 group_capab = 0;
+	if (p2p->num_groups > 0) {
+		group_capab |= P2P_GROUP_CAPAB_GROUP_OWNER;
+	}
+	p2p_buf_add_capability(buf, p2p->dev_capab &
+		~P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY, group_capab);
+	p2p_dbg(p2p, "p2p_build_probe_resp_ies:num_group:%ld.group_capab:%x",
+		p2p->num_groups, group_capab);
+#else
 	p2p_buf_add_capability(buf, p2p->dev_capab &
 			       ~P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY, 0);
+#endif
 	if (p2p->ext_listen_interval)
 		p2p_buf_add_ext_listen_timing(buf, p2p->ext_listen_period,
 					      p2p->ext_listen_interval);
@@ -3585,10 +3626,23 @@
 
 	if (dev_id)
 		p2p_buf_add_device_id(ies, dev_id);
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	/* If as GO, change probe_req listening channel to AP networking */
+	if (p2p_get_group_flag(p2p) == 1) {
+		p2p_buf_add_listen_channel(ies, p2p->cfg->country,
+			p2p->op_reg_class, p2p->op_channel);
+	} else {
+		if (p2p->cfg->reg_class && p2p->cfg->channel) {
+			p2p_buf_add_listen_channel(ies, p2p->cfg->country,
+				p2p->cfg->reg_class, p2p->cfg->channel);
+		}
+	}
+#else
 	if (p2p->cfg->reg_class && p2p->cfg->channel)
 		p2p_buf_add_listen_channel(ies, p2p->cfg->country,
 					   p2p->cfg->reg_class,
 					   p2p->cfg->channel);
+#endif
 	if (p2p->ext_listen_interval)
 		p2p_buf_add_ext_listen_timing(ies, p2p->ext_listen_period,
 					      p2p->ext_listen_interval);
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/src/drivers/driver_nl80211.c wpa_supplicant_8/src/drivers/driver_nl80211.c
--- origin_wpa/src/drivers/driver_nl80211.c	2023-05-22 11:07:37.031008779 +0800
+++ wpa_supplicant_8/src/drivers/driver_nl80211.c	2023-08-01 17:22:22.060910125 +0800
@@ -10425,8 +10425,10 @@
 #ifdef ANDROID_P2P
 	.set_noa = wpa_driver_set_p2p_noa,
 	.get_noa = wpa_driver_get_p2p_noa,
-	.set_ap_wps_ie = wpa_driver_set_ap_wps_p2p_ie,
 #endif /* ANDROID_P2P */
+#if defined CONNECTIVITY_SET_P2P_IE_PATCH || defined ANDROID_P2P
+	.set_ap_wps_ie = wpa_driver_set_ap_wps_p2p_ie,
+#endif
 #ifdef ANDROID
 #ifndef ANDROID_LIB_STUB
 	.driver_cmd = wpa_driver_nl80211_driver_cmd,
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/src/drivers/driver_nl80211.h wpa_supplicant_8/src/drivers/driver_nl80211.h
--- origin_wpa/src/drivers/driver_nl80211.h	2023-05-22 11:07:37.031008779 +0800
+++ wpa_supplicant_8/src/drivers/driver_nl80211.h	2023-08-01 17:23:20.252073903 +0800
@@ -281,11 +281,13 @@
 int wpa_driver_set_p2p_noa(void *priv, u8 count, int start, int duration);
 int wpa_driver_get_p2p_noa(void *priv, u8 *buf, size_t len);
 int wpa_driver_set_p2p_ps(void *priv, int legacy_ps, int opp_ps, int ctwindow);
+#endif /* ANDROID_P2P */
+#endif /* ANDROID */
+#if defined CONNECTIVITY_SET_P2P_IE_PATCH || defined ANDROID || defined ANDROID_P2P
 int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
 				 const struct wpabuf *proberesp,
 				 const struct wpabuf *assocresp);
-#endif /* ANDROID_P2P */
-#endif /* ANDROID */
+#endif
 
 
 /* driver_nl80211_scan.c */
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/src/drivers/driver_nl80211_android.c wpa_supplicant_8/src/drivers/driver_nl80211_android.c
--- origin_wpa/src/drivers/driver_nl80211_android.c	2023-05-22 11:07:37.031008779 +0800
+++ wpa_supplicant_8/src/drivers/driver_nl80211_android.c	2023-08-01 17:24:52.981376217 +0800
@@ -19,7 +19,9 @@
 #include "utils/common.h"
 #include "driver_nl80211.h"
 #include "android_drv.h"
-
+#ifdef CONNECTIVITY_SET_P2P_IE_PATCH
+#include "wpa_supplicant_i.h"
+#endif
 
 typedef struct android_wifi_priv_cmd {
 	char *buf;
@@ -170,17 +172,117 @@
 	return -1;
 }
 
+#endif /* ANDROID_LIB_STUB */
+#endif /* ANDROID_P2P */
+
+#ifdef CONNECTIVITY_SET_P2P_IE_PATCH
+int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
+				  size_t buf_len)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct ifreq ifr;
+	android_wifi_priv_cmd priv_cmd;
+	int ret = 0;
+
+	if (bss->ifindex <= 0 && bss->wdev_id > 0) {
+		/* DRIVER CMD received on the DEDICATED P2P Interface which doesn't
+		 * have an NETDEVICE associated with it. So we have to re-route the
+		 * command to the parent NETDEVICE
+		 */
+		struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
+
+		wpa_printf(MSG_DEBUG, "Re-routing DRIVER cmd to parent iface");
+		if (wpa_s && wpa_s->parent) {
+			/* Update the nl80211 pointers corresponding to parent iface */
+			bss = wpa_s->parent->drv_priv;
+			drv = bss->drv;
+			wpa_printf(MSG_DEBUG, "Re-routing command to iface: %s"
+					      " cmd (%s)", bss->ifname, cmd);
+		}
+	}
+	os_memcpy(buf, cmd, strlen(cmd) + 1);
+	memset(&ifr, 0, sizeof(ifr));
+	memset(&priv_cmd, 0, sizeof(priv_cmd));
+	os_strlcpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
+	priv_cmd.buf = buf;
+	priv_cmd.used_len = buf_len;
+	priv_cmd.total_len = buf_len;
+	ifr.ifr_data = (void *)&priv_cmd;
+
+	if ((ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 1, &ifr)) < 0) {
+		wpa_printf(MSG_ERROR, "%s: failed to issue private command: %s", __func__, cmd);
+		wpa_driver_send_hang_msg(drv);
+	} else {
+		drv_errors = 0;
+		ret = 0;
+		if ((os_strcasecmp(cmd, "LINKSPEED") == 0) ||
+			(os_strcasecmp(cmd, "RSSI") == 0) ||
+			(os_strcasecmp(cmd, "GETBAND") == 0) ||
+			(os_strncasecmp(cmd, "WLS_BATCHING", 12) == 0))
+			ret = strlen(buf);
+		wpa_printf(MSG_DEBUG, "%s %s len = %d, %zu", __func__, buf, ret, strlen(buf));
+	}
+	return ret;
+}
 
 int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
 				 const struct wpabuf *proberesp,
 				 const struct wpabuf *assocresp)
 {
-	return 0;
-}
+	char *buf;
+	const struct wpabuf *ap_wps_p2p_ie = NULL;
+	char *_cmd = "SET_AP_WPS_P2P_IE";
+	char *pbuf;
+	int ret = 0;
+	int i, buf_len;
+	struct cmd_desc {
+		int cmd;
+		const struct wpabuf *src;
+	} cmd_arr[] = {
+		{0x1, beacon},
+		{0x2, proberesp},
+		{0x4, assocresp},
+		{-1, NULL}
+	};
+
+	wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
+	for (i = 0; cmd_arr[i].cmd != -1; i++) {
+		ap_wps_p2p_ie = cmd_arr[i].src;
+		if (ap_wps_p2p_ie) {
+			buf_len = strlen(_cmd) + 3 + wpabuf_len(ap_wps_p2p_ie);
+			buf = os_zalloc(buf_len);
+			if (NULL == buf) {
+				wpa_printf(MSG_ERROR, "%s: Out of memory",
+				__func__);
+				ret = -1;
+				break;
+			}
+		} else {
+		continue;
+		}
+		pbuf = buf;
+		pbuf += snprintf(pbuf, buf_len - wpabuf_len(ap_wps_p2p_ie),
+				"%s %d",_cmd, cmd_arr[i].cmd);
+		*pbuf++ = '\0';
+		os_memcpy(pbuf, wpabuf_head(ap_wps_p2p_ie), wpabuf_len(ap_wps_p2p_ie));
+		ret = wpa_driver_nl80211_driver_cmd(priv, buf, buf, buf_len);
+		os_free(buf);
+		if (ret < 0)
+			break;
+	}
 
-#endif /* ANDROID_LIB_STUB */
-#endif /* ANDROID_P2P */
+	return ret;
+}
 
+#elif defined(ANDROID_P2P) && defined(ANDROID_LIB_STUB)
+int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
+				 const struct wpabuf *proberesp,
+				 const struct wpabuf *assocresp)
+{
+	return 0;
+}
+#endif
 
 int android_nl_socket_set_nonblocking(struct nl_handle *handle)
 {
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/src/drivers/drivers.mak wpa_supplicant_8/src/drivers/drivers.mak
--- origin_wpa/src/drivers/drivers.mak	2023-05-22 11:07:37.035008779 +0800
+++ wpa_supplicant_8/src/drivers/drivers.mak	2023-08-01 17:26:04.936331828 +0800
@@ -37,6 +37,10 @@
 
 ifdef CONFIG_DRIVER_NL80211
 DRV_CFLAGS += -DCONFIG_DRIVER_NL80211
+ifdef CONNECTIVITY_SET_P2P_IE_PATCH
+DRV_CFLAGS += -I$(abspath ../wpa_supplicant/)
+DRV_OBJS += ../src/drivers/driver_nl80211_android.o
+endif
 DRV_OBJS += ../src/drivers/driver_nl80211.o
 DRV_OBJS += ../src/drivers/driver_nl80211_capa.o
 DRV_OBJS += ../src/drivers/driver_nl80211_event.o
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/src/p2p/p2p.c wpa_supplicant_8/src/p2p/p2p.c
--- origin_wpa/src/p2p/p2p.c	2023-05-22 11:07:37.051008779 +0800
+++ wpa_supplicant_8/src/p2p/p2p.c	2023-08-02 17:16:37.385498636 +0800
@@ -249,6 +249,21 @@
 	p2p->cfg->go_neg_completed(p2p->cfg->cb_ctx, &res);
 }
 
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+static int p2p_get_group_flag(struct p2p_data *p2p)
+{
+	size_t i;
+	struct p2p_group *group;
+
+	for (i = 0; i < p2p->num_groups; i++) {
+		group = p2p->groups[i];
+		if (os_memcmp(p2p_group_get_interface_addr(group),
+			p2p->cfg->dev_addr, ETH_ALEN) == 0)
+			return 1;
+	}
+	return 0;
+}
+#endif
 
 static void p2p_listen_in_find(struct p2p_data *p2p, int dev_disc)
 {
@@ -287,7 +302,14 @@
 		p2p_set_timeout(p2p, 0, 0);
 		return;
 	}
-
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	/* If the functions as the GO, no listening is required.*/
+	if (p2p_get_group_flag(p2p) == 1) {
+		p2p_dbg(p2p, "p2p_listen_in_find go no response");
+		p2p_set_timeout(p2p, 0, 0);
+		return;
+	}
+#endif
 	ies = p2p_build_probe_resp_ies(p2p, NULL, 0);
 	if (ies == NULL)
 		return;
@@ -337,6 +359,14 @@
 		return 0;
 	}
 
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	/* If the functions as the GO, no listening is required.*/
+	if (p2p_get_group_flag(p2p) == 1) {
+		p2p_dbg(p2p, "p2p_listen go no response");
+		p2p_set_state(p2p, P2P_LISTEN_ONLY);
+		return 0;
+	}
+#endif
 	ies = p2p_build_probe_resp_ies(p2p, NULL, 0);
 	if (ies == NULL)
 		return -1;
@@ -2242,8 +2272,19 @@
 
 	/* P2P IE */
 	len = p2p_buf_add_ie_hdr(buf);
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	u8 group_capab = 0;
+	if (p2p->num_groups > 0) {
+		group_capab |= P2P_GROUP_CAPAB_GROUP_OWNER;
+	}
+	p2p_buf_add_capability(buf, p2p->dev_capab &
+		~P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY, group_capab);
+	p2p_dbg(p2p, "p2p_build_probe_resp_ies:num_group:%ld.group_capab:%x",
+		p2p->num_groups, group_capab);
+#else
 	p2p_buf_add_capability(buf, p2p->dev_capab &
 			       ~P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY, 0);
+#endif
 	if (p2p->ext_listen_interval)
 		p2p_buf_add_ext_listen_timing(buf, p2p->ext_listen_period,
 					      p2p->ext_listen_interval);
@@ -3585,10 +3626,23 @@
 
 	if (dev_id)
 		p2p_buf_add_device_id(ies, dev_id);
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	/* If as GO, change probe_req listening channel to AP networking */
+	if (p2p_get_group_flag(p2p) == 1) {
+		p2p_buf_add_listen_channel(ies, p2p->cfg->country,
+			p2p->op_reg_class, p2p->op_channel);
+	} else {
+		if (p2p->cfg->reg_class && p2p->cfg->channel) {
+			p2p_buf_add_listen_channel(ies, p2p->cfg->country,
+				p2p->cfg->reg_class, p2p->cfg->channel);
+		}
+	}
+#else
 	if (p2p->cfg->reg_class && p2p->cfg->channel)
 		p2p_buf_add_listen_channel(ies, p2p->cfg->country,
 					   p2p->cfg->reg_class,
 					   p2p->cfg->channel);
+#endif
 	if (p2p->ext_listen_interval)
 		p2p_buf_add_ext_listen_timing(ies, p2p->ext_listen_period,
 					      p2p->ext_listen_interval);
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/wpa_supplicant/Makefile wpa_supplicant_8/wpa_supplicant/Makefile
--- origin_wpa/wpa_supplicant/Makefile	2023-05-22 11:07:37.071008779 +0800
+++ wpa_supplicant_8/wpa_supplicant/Makefile	2023-08-01 16:29:38.446112273 +0800
@@ -1802,6 +1802,14 @@
 OBJS_nfc += $(FST_OBJS)
 endif
 
+ifdef CONFIG_CONNECTIVITY_SET_P2P_IE_PATCH
+CFLAGS += -DCONNECTIVITY_SET_P2P_IE_PATCH
+endif
+
+ifdef CONFIG_CONNECTIVITY_SINGLE_VAP_PATCH
+CFLAGS += -DCONNECTIVITY_SINGLE_VAP_PATCH
+endif
+
 ifndef LDO
 LDO=$(CC)
 endif
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/wpa_supplicant/defconfig wpa_supplicant_8/wpa_supplicant/defconfig
--- origin_wpa/wpa_supplicant/defconfig	2023-05-22 11:07:37.079008778 +0800
+++ wpa_supplicant_8/wpa_supplicant/defconfig	2023-08-01 17:27:49.056267414 +0800
@@ -491,6 +491,12 @@
 # more information on P2P operations.
 #CONFIG_P2P=y
 
+# Implementation of Complement Function (wpa_driver_set_ap_wps_p2p_ie)
+CONFIG_CONNECTIVITY_SET_P2P_IE_PATCH=y
+
+# patch for P2P single VAP
+CONFIG_CONNECTIVITY_SINGLE_VAP_PATCH=y
+
 # Enable TDLS support
 #CONFIG_TDLS=y
 
@@ -588,3 +594,4 @@
 # Opportunistic Wireless Encryption (OWE)
 # Experimental implementation of draft-harkins-owe-07.txt
 #CONFIG_OWE=y
+
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/wpa_supplicant/src/drivers/driver_nl80211.c wpa_supplicant_8/wpa_supplicant/src/drivers/driver_nl80211.c
--- origin_wpa/wpa_supplicant/src/drivers/driver_nl80211.c	2023-05-22 11:07:37.031008779 +0800
+++ wpa_supplicant_8/wpa_supplicant/src/drivers/driver_nl80211.c	2023-08-01 17:22:22.060910125 +0800
@@ -10425,8 +10425,10 @@
 #ifdef ANDROID_P2P
 	.set_noa = wpa_driver_set_p2p_noa,
 	.get_noa = wpa_driver_get_p2p_noa,
-	.set_ap_wps_ie = wpa_driver_set_ap_wps_p2p_ie,
 #endif /* ANDROID_P2P */
+#if defined CONNECTIVITY_SET_P2P_IE_PATCH || defined ANDROID_P2P
+	.set_ap_wps_ie = wpa_driver_set_ap_wps_p2p_ie,
+#endif
 #ifdef ANDROID
 #ifndef ANDROID_LIB_STUB
 	.driver_cmd = wpa_driver_nl80211_driver_cmd,
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/wpa_supplicant/src/drivers/driver_nl80211.h wpa_supplicant_8/wpa_supplicant/src/drivers/driver_nl80211.h
--- origin_wpa/wpa_supplicant/src/drivers/driver_nl80211.h	2023-05-22 11:07:37.031008779 +0800
+++ wpa_supplicant_8/wpa_supplicant/src/drivers/driver_nl80211.h	2023-08-01 17:23:20.252073903 +0800
@@ -281,11 +281,13 @@
 int wpa_driver_set_p2p_noa(void *priv, u8 count, int start, int duration);
 int wpa_driver_get_p2p_noa(void *priv, u8 *buf, size_t len);
 int wpa_driver_set_p2p_ps(void *priv, int legacy_ps, int opp_ps, int ctwindow);
+#endif /* ANDROID_P2P */
+#endif /* ANDROID */
+#if defined CONNECTIVITY_SET_P2P_IE_PATCH || defined ANDROID || defined ANDROID_P2P
 int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
 				 const struct wpabuf *proberesp,
 				 const struct wpabuf *assocresp);
-#endif /* ANDROID_P2P */
-#endif /* ANDROID */
+#endif
 
 
 /* driver_nl80211_scan.c */
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/wpa_supplicant/src/drivers/driver_nl80211_android.c wpa_supplicant_8/wpa_supplicant/src/drivers/driver_nl80211_android.c
--- origin_wpa/wpa_supplicant/src/drivers/driver_nl80211_android.c	2023-05-22 11:07:37.031008779 +0800
+++ wpa_supplicant_8/wpa_supplicant/src/drivers/driver_nl80211_android.c	2023-08-01 17:24:52.981376217 +0800
@@ -19,7 +19,9 @@
 #include "utils/common.h"
 #include "driver_nl80211.h"
 #include "android_drv.h"
-
+#ifdef CONNECTIVITY_SET_P2P_IE_PATCH
+#include "wpa_supplicant_i.h"
+#endif
 
 typedef struct android_wifi_priv_cmd {
 	char *buf;
@@ -170,17 +172,117 @@
 	return -1;
 }
 
+#endif /* ANDROID_LIB_STUB */
+#endif /* ANDROID_P2P */
+
+#ifdef CONNECTIVITY_SET_P2P_IE_PATCH
+int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
+				  size_t buf_len)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct ifreq ifr;
+	android_wifi_priv_cmd priv_cmd;
+	int ret = 0;
+
+	if (bss->ifindex <= 0 && bss->wdev_id > 0) {
+		/* DRIVER CMD received on the DEDICATED P2P Interface which doesn't
+		 * have an NETDEVICE associated with it. So we have to re-route the
+		 * command to the parent NETDEVICE
+		 */
+		struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
+
+		wpa_printf(MSG_DEBUG, "Re-routing DRIVER cmd to parent iface");
+		if (wpa_s && wpa_s->parent) {
+			/* Update the nl80211 pointers corresponding to parent iface */
+			bss = wpa_s->parent->drv_priv;
+			drv = bss->drv;
+			wpa_printf(MSG_DEBUG, "Re-routing command to iface: %s"
+					      " cmd (%s)", bss->ifname, cmd);
+		}
+	}
+	os_memcpy(buf, cmd, strlen(cmd) + 1);
+	memset(&ifr, 0, sizeof(ifr));
+	memset(&priv_cmd, 0, sizeof(priv_cmd));
+	os_strlcpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
+	priv_cmd.buf = buf;
+	priv_cmd.used_len = buf_len;
+	priv_cmd.total_len = buf_len;
+	ifr.ifr_data = (void *)&priv_cmd;
+
+	if ((ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 1, &ifr)) < 0) {
+		wpa_printf(MSG_ERROR, "%s: failed to issue private command: %s", __func__, cmd);
+		wpa_driver_send_hang_msg(drv);
+	} else {
+		drv_errors = 0;
+		ret = 0;
+		if ((os_strcasecmp(cmd, "LINKSPEED") == 0) ||
+			(os_strcasecmp(cmd, "RSSI") == 0) ||
+			(os_strcasecmp(cmd, "GETBAND") == 0) ||
+			(os_strncasecmp(cmd, "WLS_BATCHING", 12) == 0))
+			ret = strlen(buf);
+		wpa_printf(MSG_DEBUG, "%s %s len = %d, %zu", __func__, buf, ret, strlen(buf));
+	}
+	return ret;
+}
 
 int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
 				 const struct wpabuf *proberesp,
 				 const struct wpabuf *assocresp)
 {
-	return 0;
-}
+	char *buf;
+	const struct wpabuf *ap_wps_p2p_ie = NULL;
+	char *_cmd = "SET_AP_WPS_P2P_IE";
+	char *pbuf;
+	int ret = 0;
+	int i, buf_len;
+	struct cmd_desc {
+		int cmd;
+		const struct wpabuf *src;
+	} cmd_arr[] = {
+		{0x1, beacon},
+		{0x2, proberesp},
+		{0x4, assocresp},
+		{-1, NULL}
+	};
+
+	wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
+	for (i = 0; cmd_arr[i].cmd != -1; i++) {
+		ap_wps_p2p_ie = cmd_arr[i].src;
+		if (ap_wps_p2p_ie) {
+			buf_len = strlen(_cmd) + 3 + wpabuf_len(ap_wps_p2p_ie);
+			buf = os_zalloc(buf_len);
+			if (NULL == buf) {
+				wpa_printf(MSG_ERROR, "%s: Out of memory",
+				__func__);
+				ret = -1;
+				break;
+			}
+		} else {
+		continue;
+		}
+		pbuf = buf;
+		pbuf += snprintf(pbuf, buf_len - wpabuf_len(ap_wps_p2p_ie),
+				"%s %d",_cmd, cmd_arr[i].cmd);
+		*pbuf++ = '\0';
+		os_memcpy(pbuf, wpabuf_head(ap_wps_p2p_ie), wpabuf_len(ap_wps_p2p_ie));
+		ret = wpa_driver_nl80211_driver_cmd(priv, buf, buf, buf_len);
+		os_free(buf);
+		if (ret < 0)
+			break;
+	}
 
-#endif /* ANDROID_LIB_STUB */
-#endif /* ANDROID_P2P */
+	return ret;
+}
 
+#elif defined(ANDROID_P2P) && defined(ANDROID_LIB_STUB)
+int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
+				 const struct wpabuf *proberesp,
+				 const struct wpabuf *assocresp)
+{
+	return 0;
+}
+#endif
 
 int android_nl_socket_set_nonblocking(struct nl_handle *handle)
 {
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/wpa_supplicant/src/drivers/drivers.mak wpa_supplicant_8/wpa_supplicant/src/drivers/drivers.mak
--- origin_wpa/wpa_supplicant/src/drivers/drivers.mak	2023-05-22 11:07:37.035008779 +0800
+++ wpa_supplicant_8/wpa_supplicant/src/drivers/drivers.mak	2023-08-01 17:26:04.936331828 +0800
@@ -37,6 +37,10 @@
 
 ifdef CONFIG_DRIVER_NL80211
 DRV_CFLAGS += -DCONFIG_DRIVER_NL80211
+ifdef CONNECTIVITY_SET_P2P_IE_PATCH
+DRV_CFLAGS += -I$(abspath ../wpa_supplicant/)
+DRV_OBJS += ../src/drivers/driver_nl80211_android.o
+endif
 DRV_OBJS += ../src/drivers/driver_nl80211.o
 DRV_OBJS += ../src/drivers/driver_nl80211_capa.o
 DRV_OBJS += ../src/drivers/driver_nl80211_event.o
diff -Naru -x .git -x '*.o' -x '*.d' -x .config origin_wpa/wpa_supplicant/src/p2p/p2p.c wpa_supplicant_8/wpa_supplicant/src/p2p/p2p.c
--- origin_wpa/wpa_supplicant/src/p2p/p2p.c	2023-05-22 11:07:37.051008779 +0800
+++ wpa_supplicant_8/wpa_supplicant/src/p2p/p2p.c	2023-08-02 17:16:37.385498636 +0800
@@ -249,6 +249,21 @@
 	p2p->cfg->go_neg_completed(p2p->cfg->cb_ctx, &res);
 }
 
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+static int p2p_get_group_flag(struct p2p_data *p2p)
+{
+	size_t i;
+	struct p2p_group *group;
+
+	for (i = 0; i < p2p->num_groups; i++) {
+		group = p2p->groups[i];
+		if (os_memcmp(p2p_group_get_interface_addr(group),
+			p2p->cfg->dev_addr, ETH_ALEN) == 0)
+			return 1;
+	}
+	return 0;
+}
+#endif
 
 static void p2p_listen_in_find(struct p2p_data *p2p, int dev_disc)
 {
@@ -287,7 +302,14 @@
 		p2p_set_timeout(p2p, 0, 0);
 		return;
 	}
-
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	/* If the functions as the GO, no listening is required.*/
+	if (p2p_get_group_flag(p2p) == 1) {
+		p2p_dbg(p2p, "p2p_listen_in_find go no response");
+		p2p_set_timeout(p2p, 0, 0);
+		return;
+	}
+#endif
 	ies = p2p_build_probe_resp_ies(p2p, NULL, 0);
 	if (ies == NULL)
 		return;
@@ -337,6 +359,14 @@
 		return 0;
 	}
 
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	/* If the functions as the GO, no listening is required.*/
+	if (p2p_get_group_flag(p2p) == 1) {
+		p2p_dbg(p2p, "p2p_listen go no response");
+		p2p_set_state(p2p, P2P_LISTEN_ONLY);
+		return 0;
+	}
+#endif
 	ies = p2p_build_probe_resp_ies(p2p, NULL, 0);
 	if (ies == NULL)
 		return -1;
@@ -2242,8 +2272,19 @@
 
 	/* P2P IE */
 	len = p2p_buf_add_ie_hdr(buf);
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	u8 group_capab = 0;
+	if (p2p->num_groups > 0) {
+		group_capab |= P2P_GROUP_CAPAB_GROUP_OWNER;
+	}
+	p2p_buf_add_capability(buf, p2p->dev_capab &
+		~P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY, group_capab);
+	p2p_dbg(p2p, "p2p_build_probe_resp_ies:num_group:%ld.group_capab:%x",
+		p2p->num_groups, group_capab);
+#else
 	p2p_buf_add_capability(buf, p2p->dev_capab &
 			       ~P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY, 0);
+#endif
 	if (p2p->ext_listen_interval)
 		p2p_buf_add_ext_listen_timing(buf, p2p->ext_listen_period,
 					      p2p->ext_listen_interval);
@@ -3585,10 +3626,23 @@
 
 	if (dev_id)
 		p2p_buf_add_device_id(ies, dev_id);
+#ifdef CONNECTIVITY_SINGLE_VAP_PATCH
+	/* If as GO, change probe_req listening channel to AP networking */
+	if (p2p_get_group_flag(p2p) == 1) {
+		p2p_buf_add_listen_channel(ies, p2p->cfg->country,
+			p2p->op_reg_class, p2p->op_channel);
+	} else {
+		if (p2p->cfg->reg_class && p2p->cfg->channel) {
+			p2p_buf_add_listen_channel(ies, p2p->cfg->country,
+				p2p->cfg->reg_class, p2p->cfg->channel);
+		}
+	}
+#else
 	if (p2p->cfg->reg_class && p2p->cfg->channel)
 		p2p_buf_add_listen_channel(ies, p2p->cfg->country,
 					   p2p->cfg->reg_class,
 					   p2p->cfg->channel);
+#endif
 	if (p2p->ext_listen_interval)
 		p2p_buf_add_ext_listen_timing(ies, p2p->ext_listen_period,
 					      p2p->ext_listen_interval);
